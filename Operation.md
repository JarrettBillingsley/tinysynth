# Method of operation

If you're curious how the synth works, read on!

## Using the PWM mode on timer 1

The audio output is generated by the Timer 1 peripheral, using the 16MHz system clock divided by 4, so it updates at 4MHz.

Since this is an 8-bit timer, it will take 256 clock pulses to overflow. 4MHz / 256 = 16,384 overflows per second. This is our sample frequency.

We output the sample using the "compare B" unit in the timer. Every time the timer overflows, we set the OCR1B - compare B value - to the newly-calculated 8-bit sample. This has the effect of outputting a pulse-width modulated signal whose width is proportional to the sample value. For example:

```
  1/16,384th of    1/16,384th of
    a second       a second
 _______________  _______________
/               \/               \
         _______              ___
        |       |            |   |
        |       |            |   |
________|       |____________|   |...
^               ^
|               |
OCR1B = 127     OCR1B = 192
```

## Hard real-time constraints

Since we don't have the luxury of some kind of "sample buffer," **we must calculate and output a new sample every sample period.** This doesn't sound too bad; after all, 1/16,384th of a second is a pretty long time for a computer, right?

...except our system clock is only 16MHz. 16MHz / 16,384Hz = **1024 cycles between timer overflows.** 1024 cycles to calculate a new sample *and* accept any commands from the SPI interface!

What happens if we miss the window? Well, nothing *catastrophic,* but we get an **underrun.** This means one sample will be stretched out into two sample periods, like this:

```
  1/16,384th of    1/16,384th of    1/16,384th of
    a second       a second         a second
 _______________  _______________  _______________
/               \/               \/               \
         _______          _______              ___
        |       |        |       |            |   |
        |       |        |       |            |   |
________|       |________|       |____________|   |...
^               ^                ^
|               |                |
OCR1B = 127     underrun D:      OCR1B = 192
```

An underrun will result in an audible glitch, or if it happens on every sample, it will pitch the audio down by an octave. This is pretty undesirable, so the synth has been designed to never miss a sample. Of course, if you *do* get an underrun, file an issue with how you were able to get it to happen!

## Racing the beam

The ISR (interrupt service routine) that runs when the timer overflows updates OCR1B. This routine itself takes about 10 of our 1024 cycles, leaving about **1000 cycles** to do everything else. How do we get all these features in so few cycles?

### Assembly

Initially I wrote the test code in C, but looking at the output of the compiler - even with maximum optimization - it was clear that hand-written assembly was the only way to squeeze enough performance out of the thing. Not that I mind, since I kinda started this project as a way to dig into AVR assembly to begin with :smile:

The best the C compiler could do was updating one channel in **200 cycles.** I got that down to **50 cycles** with careful assembly and data layout.

### Optimized memory layout

Each channel has a number of variables: whether or not it's enabled, rate, phase, sample length, sample start address, and volume. Rate and phase are 24 bits (3 bytes); the rest are only 1 byte.

Memory access instructions (loads and stores) take 2 cycles. Each channel has 10 bytes of data, meaning 20 cycles for loads. In addition, the phase must be read *and* written, adding another 6 cycles, meaning a minimum of **26 cycles of memory access for each channel.** With eight channels, this means we spend **208 of our 1000 cycles just reading and writing channel memory.** These accesses are unavoidable and can't be optimized away.

Address calculations would only add more cycles, meaning less time to do the sample calculations and to handle the communication interface. So the data for each channel is laid out in a funny way:

```
en    rat0  phs0  rat1  phs1  rat2  phs2  len   start vol
 0     1     2     3     4     5     6     7     8     9
```

The bytes are in the order that the channel update algorithm uses them. This way, we can use the "load with post-increment" instruction to automatically move the pointer in a single two-cycle load instruction, avoiding the need for additional address calculations. The channel data pointer only has to move forward, never backward. In addition, each step of the sample calculation can reuse the same registers over and over, leaving us more free registers for storing important variables.

The rate and phase variables are also interleaved so that we can "load and increment, load, add, store and increment" three times for the full 24-bit addition. This means it takes only 21 cycles, the minimum possible, and only requires two registers too. It's a layout I never would have considered before!

### Multiplying with a table

In order to have proper linear volume control, multiplication must be used. Unfortunately, there's no hardware multiplier on the ATTiny85.

We *could* use a software multiplication routine, but even unrolled 4bit x 4bit multiplication adds more overhead than we'd like. So instead, we use a lookup table. (This table is generated by the `volgen.py` script.)

This is feasible because we have 4-bit samples and 4-bit volumes. After getting the sample value and the volume, the `swap` instruction is used to put the volume into the high nybble, and the two values are ORed together. This gives us the offset into the volume lookup table, which only has to be 256 bytes.

Since there are only 512 bytes of RAM, half of which is used for sample RAM, there's not enough room to have the volume table in there too, so we have to locate the lookup table in program memory instead. It's not that big of a deal though, since the `lpm` instruction only takes one more cycle than an `ld` would.

This means the volume calculation takes only 6 cycles - `swap`, `or`, and `lpm`.